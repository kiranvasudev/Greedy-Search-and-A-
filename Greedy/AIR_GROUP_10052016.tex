\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\title{\textbf{Artificial Intelligence for Robotics\\ - Homework 6 -}}
\author{Kiran Vasudev, Patrick Nagel}
\date{Due date: 16.05.2016}
\begin{document}

\maketitle

\newpage
\tableofcontents


\newpage
\section{Search Strategies}
\subsection{Uniform Cost Search}
The uniform cost search is an \textbf{optimal} algorithm with any step-cost function. It stores and orders its nodes in a queue related to their path-costs. The node with the lowest path cost will be expanded. The algorithm then tests the node, which is selected, if it is the goal. Not to apply the goal test before the node with the lowest path-cost is selected avoids to choose a suboptimal solution. It makes sure that all nodes are generated and considered first. The uniform cost search also provides a test for the case that a better path to the goal is found. The  search focuses on the total costs of the nodes, which leads to the \textbf{possibility of infinite loops} if zero cost paths are given.\\
\\
The complexity of this algorithm does not depend on the depth of the search. Instead it is characterized by the path costs. In the worst case of the complexity is \textbf{$O(b^{1 + \frac{C*}{\epsilon}})$ (worst case)}. The C* represents the costs of an optimal solution and $\varepsilon$ the costs which are guaranteed at every node (can be also higher than that). In the case (that all costs are equal the complexity is \textbf{$O(b^{d + 1})$ (best case)}. The algorithm is then quite similar to breadth-first search just with the exception that the uniform cost search does not stop after finding the goal, but after checking all nodes (in case a lower cost solution exists). In this case the algorithm expands nodes unnecessarily since all costs are the same and the optimal path was alread found.


\subsection{Depth-First Search}

The Depth First Search Algorithm is an algorithm that is similar to Breadth First Search. In Breadth-First Search, the algorithm uses a queue which follows the principle of First In First Out (\textbf{FIFO}). In Depth First Search, we use the data structure of a stack that follows the principle of Last In First Out(\textbf{LIFO}). 

The algorithm starts at the root node and then traverses to the child at the left and goes right down to the deepest node in the state space or until goal state is found. If the goal is found, the goal is returned, otherwise the algorithm backtracks and visits the unvisited nodes. 

Depth First Search is optimal when we use a state space or a graph and its size is finite. If the size is infinite, then the algorithm is not optimal as it may end in infinite loops or it may return a path that is not the optimal solution.

The biggest advantage of Depth First Search is the space complexity.
The Algorithm works in two ways. First, the visited elements are pushed onto the stack and once the maximum depth of that node is reached, the elements are popped. This method is called \textbf{backtracking}.

\textbf{Complexities:}
\begin{itemize}
\item Space Complexity: \[O(bm)\]
\item Time Complexity: \[ O(b^m)\]
\end{itemize}

where b is the branching factor and m is the max depth of the state space.

\subsection{Limited Depth-First Search}
% Patrick

\subsection{Iterative-deepening Search}
The Algorithm \textbf{Iterative Deepening Search} is used when the search space is very large and the depth is unknown. IDDFS is a combination of both BFS and DFS. This algorithm uses a counter that is used to iterate through every level of the state space. This counter helps remove traversing the maximum depth of the state space like DFS and uses BFS to traverse every level. If the goal state is not found in a particular level, then the counter is incremented and the algorithm follows. In every iteration, the algorithm traverses the entire state space starting from the root node. These states are generated multiple times but this generation isn't too costly. 

\textbf{Complexities:}
\begin{itemize}
\item Space Complexity: \[O(bd)\]
\item Time Complexity: \[ O(b^d)\]
\end{itemize}
where b is the branching factor and d is the depth of least cost solution.

\subsection{Informed Search}
% Patrick

\subsection{Greedy Search}
% Kiran

\subsection{A*}
% Patrick

\subsection{Iterative A*}
% Kiran

\newpage
\section{What is a heuristic function?}
A heuristic function is one that estimates the cost of the path from a node to the closest goal state. If the node is the goal state, the cost is 0. The heuristic function is denoted by \textbf{h(n)}.

\newpage
\section{Comparison of the two heuristics. (Task 3 (b))}
% Not decided yet.

\newpage
\section{Comment if the heuristics are consistent or inconsistent. (Task 3 (c))}
% Not decided yet.
\end{document}